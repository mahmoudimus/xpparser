<?xml version="1.0"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            xmlns="http://www.w3.org/2005/XQueryX"
            targetNamespace="http://www.w3.org/2005/XQueryX"
            elementFormDefault="qualified" attributeFormDefault="qualified">


<!-- A few helper declarations                                             -->
  <xsd:complexType name="emptyContent"/>

  <xsd:element name="NCName" type="xsd:NCName"/>

  <xsd:complexType name="QName">
    <xsd:simpleContent>
      <xsd:extension base="xsd:NCName">
        <xsd:attribute name="prefix" type="xsd:NCName" use="optional"/>
      </xsd:extension>
    </xsd:simpleContent>
  </xsd:complexType>

  <xsd:complexType name="EQName">
    <xsd:simpleContent>
      <xsd:extension base="xsd:NCName">
        <xsd:attribute name="prefix" type="xsd:NCName" use="optional"/>
        <xsd:attribute name="URI" type="xsd:string" use="optional"/>
      </xsd:extension>
    </xsd:simpleContent>
  </xsd:complexType>

<!-- The base expression class                                             -->
  <xsd:complexType name="expr"/>

  <xsd:element name="expr" type="expr" abstract="true"/>


<!-- A list of expressions                                                 -->
  <xsd:complexType name="exprList">
    <xsd:sequence>
      <xsd:element ref="expr" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:complexType>

<!-- A list of expressions or placeholders                                 -->
<!-- 2010-06-23 - Added support for partial function application           -->
  <xsd:complexType name="exprOrPlaceholderList">
    <xsd:sequence>
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
        <xsd:element ref="expr"/>
        <xsd:element name="argumentPlaceholder" type="emptyContent"/>
      </xsd:choice>
    </xsd:sequence>
  </xsd:complexType>

<!-- A type to be used by elements that comprise an optional expr          -->
  <xsd:complexType name="exprWrapperOptional">
    <xsd:sequence>
      <xsd:element ref="expr" minOccurs="0"/>
    </xsd:sequence>
  </xsd:complexType>

<!-- Simple wrapper class                                                  -->
  <xsd:complexType name="exprWrapper">
    <xsd:sequence>
      <xsd:element ref="expr"/>
    </xsd:sequence>
  </xsd:complexType>

<!-- A list of literals                                                    -->
<!-- 2013-03-17 = Added new support for a list of literals, e.g.,          -->
<!-- in annotations                                                        -->
  <xsd:complexType name="literalList">
    <xsd:sequence>
      <xsd:element ref="constantExpr" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:complexType>

<!-- constant expressions. We have 4 different subclasses for this         -->
  <xsd:complexType name="constantExpr">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:sequence>
          <xsd:element name="value" type="xsd:anyType"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="constantExpr" type="constantExpr" abstract="true"
               substitutionGroup="expr"/>


  <xsd:complexType name="integerConstantExpr">
    <xsd:complexContent>
      <xsd:restriction base="constantExpr">
        <xsd:sequence>
          <xsd:element name="value" type="xsd:integer"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="integerConstantExpr" type="integerConstantExpr"
               substitutionGroup="constantExpr"/>


  <xsd:complexType name="decimalConstantExpr">
    <xsd:complexContent>
      <xsd:restriction base="constantExpr">
        <xsd:sequence>
          <xsd:element name="value" type="xsd:decimal"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="decimalConstantExpr" type="decimalConstantExpr"
               substitutionGroup="constantExpr"/>


  <xsd:complexType name="doubleConstantExpr">
    <xsd:complexContent>
      <xsd:restriction base="constantExpr">
        <xsd:sequence>
          <xsd:element name="value" type="xsd:double"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="doubleConstantExpr" type="doubleConstantExpr"
               substitutionGroup="constantExpr"/>


  <xsd:complexType name="stringConstantExpr">
    <xsd:complexContent>
      <xsd:restriction base="constantExpr">
        <xsd:sequence>
          <xsd:element name="value" type="xsd:string"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="stringConstantExpr" type="stringConstantExpr"
               substitutionGroup="constantExpr"/>


<!-- Variables                                                             -->
  <xsd:complexType name="varRef">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:sequence>
          <xsd:element name="name" type="EQName"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="varRef" type="varRef" substitutionGroup="expr"/>


<!-- root and context-item expressions                                     -->
<!-- rootExpr deleted per Bugzilla Bug #2523                               -->
  <xsd:complexType name="contextItemExpr">
    <xsd:complexContent>
      <xsd:extension base="expr"/>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="contextItemExpr" type="contextItemExpr"
               substitutionGroup="expr"/>


<!-- Simple map expressions                                                -->
<!-- 2012-06-15 - Changed precedence and precise grammar for simple map operator        -->
<!-- 2013-09-27 - Changed definition of simpleMapExpr to allow multiple path expressions-->
  <xsd:complexType name="simpleMapExpr">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:sequence minOccurs="2" maxOccurs="unbounded">
          <xsd:element ref="pathExpr"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="simpleMapExpr" type="simpleMapExpr"
               substitutionGroup="expr"/>


<!-- Function call expressions                                                          -->
<!-- 2010-06-23 - Added support for partial function application                        -->
  <xsd:complexType name="functionCallExpr">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:sequence>
          <xsd:element name="functionName" type="EQName"/>
          <xsd:element name="arguments" type="exprOrPlaceholderList" minOccurs="0"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="functionCallExpr" type="functionCallExpr"
               substitutionGroup="expr"/>


<!-- Sequence expressions                                                               -->
  <xsd:complexType name="sequenceExpr">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:sequence>
          <xsd:element ref="expr" minOccurs="0" maxOccurs="unbounded"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="sequenceExpr" type="sequenceExpr" substitutionGroup="expr"/>


  <xsd:complexType name="rangeSequenceExpr">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:sequence>
          <xsd:element name="startExpr" type="exprWrapper"/>
          <xsd:element name="endExpr" type="exprWrapper"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="rangeSequenceExpr" type="rangeSequenceExpr"
               substitutionGroup="expr"/>


<!-- Builtin operator expressions                                                       -->
  <xsd:complexType name="operatorExpr">
    <xsd:complexContent>
      <xsd:extension base="expr"/>
    </xsd:complexContent>
  </xsd:complexType>


  <xsd:complexType name="unaryOperatorExpr">
    <xsd:complexContent>
      <xsd:extension base="operatorExpr">
        <xsd:sequence>
          <xsd:element name="operand" type="exprWrapper"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>


  <xsd:complexType name="binaryOperatorExpr">
    <xsd:complexContent>
      <xsd:extension base="operatorExpr">
        <xsd:sequence>
          <xsd:element name="firstOperand" type="exprWrapper"/>
          <xsd:element name="secondOperand" type="exprWrapper"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>


<!-- General operator expressions -->
  <xsd:element name="operatorExpr" type="operatorExpr"
               abstract="true" substitutionGroup="expr"/>

<!-- Arithmetic operator expressions -->
  <xsd:element name="arithmeticOp" type="operatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/>

  <xsd:element name="addOp" type="binaryOperatorExpr"
               substitutionGroup="arithmeticOp"/>

  <xsd:element name="subtractOp" type="binaryOperatorExpr"
               substitutionGroup="arithmeticOp"/>

  <xsd:element name="multiplyOp" type="binaryOperatorExpr"
               substitutionGroup="arithmeticOp"/>

  <xsd:element name="divOp" type="binaryOperatorExpr"
               substitutionGroup="arithmeticOp"/>

  <xsd:element name="idivOp" type="binaryOperatorExpr"
               substitutionGroup="arithmeticOp"/>

  <xsd:element name="modOp" type="binaryOperatorExpr"
               substitutionGroup="arithmeticOp"/>

  <xsd:element name="unaryMinusOp" type="unaryOperatorExpr"
               substitutionGroup="arithmeticOp"/>

  <xsd:element name="unaryPlusOp" type="unaryOperatorExpr"
               substitutionGroup="arithmeticOp"/>

<!-- String operator expressions -->
  <xsd:element name="stringOp" type="operatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/>

  <xsd:element name="stringConcatenateOp" type="binaryOperatorExpr"
               substitutionGroup="stringOp"/>

<!-- Comparison operator expressions -->
  <xsd:element name="comparisonOp" type="binaryOperatorExpr" abstract="true"
               substitutionGroup="operatorExpr"/>

<!-- Value comparison operator expressions -->
  <xsd:element name="valueComparisonOp" type="binaryOperatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/>

  <xsd:element name="eqOp" type="binaryOperatorExpr"
               substitutionGroup="valueComparisonOp"/>

  <xsd:element name="neOp" type="binaryOperatorExpr"
               substitutionGroup="valueComparisonOp"/>

  <xsd:element name="gtOp" type="binaryOperatorExpr"
               substitutionGroup="valueComparisonOp"/>

  <xsd:element name="geOp" type="binaryOperatorExpr"
               substitutionGroup="valueComparisonOp"/>

  <xsd:element name="ltOp" type="binaryOperatorExpr"
               substitutionGroup="valueComparisonOp"/>

  <xsd:element name="leOp" type="binaryOperatorExpr"
               substitutionGroup="valueComparisonOp"/>

<!-- General comparison operator expressions -->
  <xsd:element name="generalComparisonOp" type="binaryOperatorExpr" abstract="true"
               substitutionGroup="operatorExpr"/>

  <xsd:element name="equalOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/>

  <xsd:element name="notEqualOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/>

  <xsd:element name="lessThanOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/>

  <xsd:element name="lessThanOrEqualOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/>

  <xsd:element name="greaterThanOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/>

  <xsd:element name="greaterThanOrEqualOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/>

<!-- Node comparison operator expressions -->
  <xsd:element name="nodeComparisonOp" type="binaryOperatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/>

  <xsd:element name="isOp" type="binaryOperatorExpr"
               substitutionGroup="nodeComparisonOp"/>

<!-- Order comparison operator expressions -->
  <xsd:element name="orderComparisonOp" type="binaryOperatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/>

  <xsd:element name="nodeBeforeOp" type="binaryOperatorExpr"
               substitutionGroup="orderComparisonOp"/>

  <xsd:element name="nodeAfterOp" type="binaryOperatorExpr"
               substitutionGroup="orderComparisonOp"/>

<!-- Logical operator expressions -->
  <xsd:element name="logicalOp" type="binaryOperatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/>

  <xsd:element name="andOp" type="binaryOperatorExpr"
               substitutionGroup="logicalOp"/>

  <xsd:element name="orOp" type="binaryOperatorExpr"
               substitutionGroup="logicalOp"/>

  <xsd:element name="setOp" type="binaryOperatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/>

  <xsd:element name="unionOp" type="binaryOperatorExpr"
               substitutionGroup="setOp"/>

  <xsd:element name="intersectOp" type="binaryOperatorExpr"
               substitutionGroup="setOp"/>

  <xsd:element name="exceptOp" type="binaryOperatorExpr"
               substitutionGroup="setOp"/>


<!-- Basic typenames                                                                    -->
<!-- By changing the type attribute from QName to EQName, this is now atomicOrUnionType -->
<!--   However, for backwards compatibility w/XQueryX 1.0, the name had to stay the same-->
  <xsd:element name="atomicType" type="EQName" substitutionGroup="itemType"/>


<!-- Used in castable expression and cast expression                                    -->
  <xsd:complexType name="singleType">
    <xsd:sequence>
      <xsd:element ref="atomicType"/>
      <xsd:element name="optional" type="emptyContent" minOccurs="0"/>
    </xsd:sequence>
  </xsd:complexType>

  <xsd:element name="singleType" type="singleType"/>


<!-- Item type schema types and elements                                                -->
  <xsd:element name="itemType" abstract="true"/>

  <xsd:complexType name="emptyItemTypeContent"/>

  <xsd:element name="anyItemType" type="emptyItemTypeContent"
               substitutionGroup="itemType"/>


  <xsd:simpleType name="occurrenceIndicator">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="?"/>
      <xsd:enumeration value="*"/>
      <xsd:enumeration value="+"/>
    </xsd:restriction>
  </xsd:simpleType>


<!-- Sequence type                                                                      -->
  <xsd:complexType name="sequenceType">
    <xsd:choice>
      <xsd:element name="voidSequenceType" type="emptyContent"/>
      <xsd:sequence>
        <xsd:element ref="itemType"/>
        <xsd:element name="occurrenceIndicator" type="occurrenceIndicator"
                     minOccurs="0"/>
      </xsd:sequence>
    </xsd:choice>
  </xsd:complexType>

  <xsd:element name="sequenceType" type="sequenceType"/>

  <xsd:element name="typeDeclaration" type="sequenceType"/>


<!-- Represents a "typed" variable (for clause, let clause etc)                         -->
  <xsd:complexType name="typedVariableBinding">
    <xsd:sequence>
      <xsd:element name="varName" type="EQName"/>
      <xsd:element ref="typeDeclaration" minOccurs="0"/>
    </xsd:sequence>
  </xsd:complexType>

  <xsd:element name="typedVariableBinding" type="typedVariableBinding"/>


<!-- Represents all variable bindings in a for or let clause except typed and           -->
<!--   positional variable bindings                                                     -->
  <xsd:element name="forLetClauseItemExtensions" abstract="true"/>


<!-- Major syntax productions: FLWOR clause components                                  -->
<!-- for clause                                                                         -->
  <xsd:complexType name="forClauseItem">
    <xsd:sequence>
      <xsd:element ref="typedVariableBinding"/>
      <xsd:element name="forExpr" type="exprWrapper"/>
    </xsd:sequence>
  </xsd:complexType>

  <xsd:element name="forClauseItem" type="forClauseItem"/>


  <xsd:complexType name="forClause">
    <xsd:sequence>
      <xsd:element ref="forClauseItem" minOccurs="1" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:complexType>

  <xsd:element name="forClause" type="forClause"/>


<!-- let clause                                                                         -->
  <xsd:complexType name="letClauseItem">
    <xsd:sequence>
      <xsd:element ref="typedVariableBinding"/>
      <xsd:element name="letExpr" type="exprWrapper"/>
    </xsd:sequence>
  </xsd:complexType>

  <xsd:element name="letClauseItem" type="letClauseItem"/>


  <xsd:complexType name="letClause">
    <xsd:sequence>
      <xsd:element ref="letClauseItem" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:complexType>

  <xsd:element name="letClause" type="letClause"/>


<!-- return clause                                                                      -->
  <xsd:element name="returnClause" type="exprWrapper"/>


<!-- This is the XQuery 3.0 flwor expression                                            -->
<!-- Corresponds to the following XQuery syntax:                                        -->
<!-- 1.1 FLWORExpr ::= (ForClause | LetClause | WindowClause)                           -->
<!--                   (ForClause | LetClause | WindowClause | CountClause |            -->
<!--                    WhereClause | GroupByClause | OrderByClause)*                   -->
<!--                   ReturnClause                                                     -->
  <xsd:complexType name="flworExpr">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:sequence>
          <xsd:choice>
            <xsd:sequence maxOccurs="unbounded">
              <xsd:element ref="forClause"/>
            </xsd:sequence>
            <xsd:sequence maxOccurs="unbounded">
              <xsd:element ref="letClause"/>
            </xsd:sequence>
          </xsd:choice>
          <xsd:element ref="returnClause"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="flworExpr" type="flworExpr" substitutionGroup="expr"/>


<!-- conditional expressions                                                            -->
  <xsd:complexType name="ifThenElseExpr">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:sequence>
          <xsd:element name="ifClause" type="exprWrapper"/>
          <xsd:element name="thenClause" type="exprWrapper"/>
          <xsd:element name="elseClause" type="exprWrapper"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="ifThenElseExpr" type="ifThenElseExpr" 
               substitutionGroup="expr"/>


<!-- The following clauses describe quantified expressions                              -->
  <xsd:simpleType name="quantifier">
    <xsd:restriction base="xsd:NMTOKEN">
      <xsd:enumeration value="some"/>
      <xsd:enumeration value="every"/>
    </xsd:restriction>
  </xsd:simpleType>


  <xsd:complexType name="quantifiedExprInClause">
    <xsd:sequence>
      <xsd:element ref="typedVariableBinding"/>
      <xsd:element name="sourceExpr" type="exprWrapper"/>
    </xsd:sequence>
  </xsd:complexType>

  <xsd:element name="quantifiedExprInClause" type="quantifiedExprInClause"/>


  <xsd:complexType name="quantifiedExpr">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:sequence>
          <xsd:element name="quantifier" type="quantifier"/>
          <xsd:element ref="quantifiedExprInClause" maxOccurs="unbounded"/>
          <xsd:element name="predicateExpr" type="exprWrapper"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="quantifiedExpr" type="quantifiedExpr"
               substitutionGroup="expr"/>

<!-- instance-of expressions                                                            -->
  <xsd:complexType name="instanceOfExpr">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:sequence>
          <xsd:element name="argExpr" type="exprWrapper"/>
          <xsd:element ref="sequenceType"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="instanceOfExpr" type="instanceOfExpr"
               substitutionGroup="expr"/>


<!-- treat-as expressions                                                               -->
  <xsd:complexType name="treatExpr">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:sequence>
          <xsd:element name="argExpr" type="exprWrapper"/>
          <xsd:element ref="sequenceType"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="treatExpr" type="treatExpr"
               substitutionGroup="expr"/>


<!-- castable and cast expressions                                                      -->
  <xsd:complexType name="castableExpr">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:sequence>
          <xsd:element name="argExpr" type="exprWrapper"/>
          <xsd:element ref="singleType"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="castableExpr" type="castableExpr"
               substitutionGroup="expr"/>


  <xsd:complexType name="castExpr">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:sequence>
          <xsd:element name="argExpr" type="exprWrapper"/>
          <xsd:element ref="singleType"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="castExpr" type="castExpr"
               substitutionGroup="expr"/>

<!-- function item expressions                                                          -->
<!-- literal function item expression                                                   -->
<!-- 2010-04-06: Jim changed child element QName to be functionName for consistency     -->
<!-- 2011-11-21: Jim changed "literalFunctionItemExpr" to "namedFunctionRef"            -->
  <xsd:complexType name="namedFunctionRef">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:sequence>
          <xsd:element name="functionName" type="EQName"/>
          <xsd:element name="integerConstantExpr" type="integerConstantExpr"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="namedFunctionRef" type="namedFunctionRef" substitutionGroup="expr"/>


<!-- inline function item expression                                                    -->
<!-- 2011-09-09/JM - Added annotations to inline functions                              -->
<!-- 2011-11-21: Jim changed "inlineFunctionItemExpr" to "inlineFunctionExpr"           -->
  <xsd:complexType name="inlineFunctionExpr">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:sequence>
          <xsd:element name="annotation" type="annotation"
                       minOccurs="0" maxOccurs="unbounded"/>
          <xsd:element ref="paramList"/>
          <xsd:element ref="typeDeclaration" minOccurs="0"/>
          <xsd:element name="functionBody" type="exprWrapper"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="inlineFunctionExpr" type="inlineFunctionExpr" substitutionGroup="expr"/>


<!-- dynamic function invocations                                                       -->
<!-- 2010-06-23 - Added support for partial function application                        -->
  <xsd:complexType name="dynamicFunctionInvocationExpr">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:sequence>
          <xsd:element name="functionItem">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:group ref="filterExpr"/>
              </xsd:sequence>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="predicates" type="exprList" minOccurs="0"/>
          <xsd:element name="arguments" type="exprOrPlaceholderList" minOccurs="0"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="dynamicFunctionInvocationExpr" type="dynamicFunctionInvocationExpr" substitutionGroup="expr"/>


<!-- wildcards                                                                          -->
  <xsd:complexType name="simpleWildcard">
    <xsd:choice>
      <xsd:element name="QName" type="EQName"/>
      <xsd:element name="star" type="emptyContent"/>
    </xsd:choice>
  </xsd:complexType>

<!-- 2011-06-10: Redesigned to allow "URliteral:*"                                                  -->
<!-- Corresponds to the following XQuery syntax:                                                    -->
<!--   [44] Wildcard ::= "*"                                                                        -->
<!--                  | (NCName ":" "*")                                                            -->
<!--                  | ("*" ":" NCName)                                                            -->
<!--                  | (URILiteral ":" "*")                                                        -->

  <xsd:complexType name="Wildcard">
    <xsd:choice minOccurs="0">
      <xsd:sequence>
        <xsd:element name="star" type="emptyContent"/>
        <xsd:element ref="NCName"/>
      </xsd:sequence>
      <xsd:sequence>
        <xsd:element ref="NCName"/>
        <xsd:element name="star" type="emptyContent"/>
      </xsd:sequence>
      <xsd:sequence>
        <xsd:element name="uri" type="xsd:string"/>
        <xsd:element name="star" type="emptyContent"/>
      </xsd:sequence>
    </xsd:choice>
  </xsd:complexType>

  <xsd:element name="Wildcard" type="Wildcard"/>


<!-- tests (name and/or type)                                                           -->
  <xsd:element name="schemaAttributeTest" type="EQName"
               substitutionGroup="kindTest"/>


  <xsd:complexType name="attributeTest">
    <xsd:complexContent>
      <xsd:extension base="emptyItemTypeContent">
        <xsd:sequence minOccurs="0">
          <xsd:element name="attributeName" type="simpleWildcard"/>
          <xsd:element name="typeName" type="EQName" minOccurs="0"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="attributeTest" type="attributeTest"
               substitutionGroup="kindTest"/>


  <xsd:element name="anyElementTest" abstract="true"
               substitutionGroup="kindTest"/>


  <xsd:element name="schemaElementTest" type="EQName"
               substitutionGroup="anyElementTest"/>


  <xsd:complexType name="elementTest">
    <xsd:complexContent>
      <xsd:extension base="emptyItemTypeContent">
        <xsd:sequence minOccurs="0">
          <xsd:element name="elementName" type="simpleWildcard"/>
          <xsd:sequence minOccurs="0">
            <xsd:element name="typeName" type="EQName"/>
            <xsd:element name="nillable" type="emptyContent" minOccurs="0"/>
          </xsd:sequence>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="elementTest" type="elementTest"
               substitutionGroup="anyElementTest"/>


  <xsd:complexType name="documentTest">
    <xsd:complexContent>
      <xsd:extension base="emptyItemTypeContent">
        <xsd:sequence>
           <xsd:element ref="anyElementTest" minOccurs="0"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="documentTest" type="documentTest"
               substitutionGroup="kindTest"/>


  <xsd:complexType name="piTest">
    <xsd:complexContent>
      <xsd:extension base="emptyItemTypeContent">
        <xsd:sequence>
          <xsd:element name="piTarget" type="xsd:NCName" minOccurs="0"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="piTest" type="piTest" substitutionGroup="kindTest"/>


  <xsd:element name="nameTest" type="EQName"/>

  <xsd:element name="kindTest" substitutionGroup="itemType"/>

  <xsd:element name="textTest" type="emptyItemTypeContent"
               substitutionGroup="kindTest"/>

  <xsd:element name="commentTest" type="emptyItemTypeContent"
               substitutionGroup="kindTest"/>

  <xsd:element name="namespaceTest" type="emptyItemTypeContent"
               substitutionGroup="kindTest"/>

  <xsd:element name="anyKindTest" type="emptyItemTypeContent"
               substitutionGroup="kindTest"/>


<!-- functionTest variations -->
<!-- 2012-09-07: Jim added annotation support -->
  <xsd:complexType name="anyFunctionTest">
    <xsd:complexContent>
      <xsd:extension base="emptyItemTypeContent">
        <xsd:sequence>
          <xsd:element name="annotation" type="annotation"
                       minOccurs="0" maxOccurs="unbounded"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="anyFunctionTest" type="anyFunctionTest" substitutionGroup="itemType"/>

<!-- 2012-09-07: Jim added annotation support -->
  <xsd:complexType name="typedFunctionTest">
    <xsd:complexContent>
      <xsd:extension base="emptyItemTypeContent">
        <xsd:sequence>
          <xsd:element name="annotation" type="annotation"
                       minOccurs="0" maxOccurs="unbounded"/>
          <xsd:element ref="paramTypeList" minOccurs="0"/>
          <xsd:element ref="sequenceType"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="typedFunctionTest" type="typedFunctionTest" substitutionGroup="itemType"/>


  <xsd:complexType name="paramTypeList">
    <xsd:sequence>
      <xsd:element ref="sequenceType" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:complexType>

  <xsd:element name="paramTypeList" type="paramTypeList"/>


  <xsd:complexType name="parenthesizedItemType">
    <xsd:complexContent>
      <xsd:extension base="emptyItemTypeContent">
        <xsd:sequence>
          <xsd:element ref="itemType"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="parenthesizedItemType" type="parenthesizedItemType" substitutionGroup="itemType"/>


<!-- XPath axes                                                                         -->
  <xsd:simpleType name="xpathAxis">
    <xsd:restriction base="xsd:NMTOKEN">
      <xsd:enumeration value="child"/>
      <xsd:enumeration value="attribute"/>
      <xsd:enumeration value="self"/>
      <xsd:enumeration value="parent"/>
      <xsd:enumeration value="descendant-or-self"/>
      <xsd:enumeration value="descendant"/>
      <xsd:enumeration value="following"/>
      <xsd:enumeration value="following-sibling"/>
      <xsd:enumeration value="ancestor"/>
      <xsd:enumeration value="ancestor-or-self"/>
      <xsd:enumeration value="preceding"/>
      <xsd:enumeration value="preceding-sibling"/>
    </xsd:restriction>
  </xsd:simpleType>

  <xsd:element name="xpathAxis" type="xpathAxis"/>


<!-- filter expressions                                                                 -->
<!-- added literalFunctionItemExpr, inlineFunctionItemExpr, and                         -->
<!--   dynamicFunctionInvocation for higher-order functions                             -->
<!-- 2011-11-21: Jim changed "literalFunctionItemExpr" to "namedFunctionRef"            -->
<!-- 2011-11-21: Jim changed "inlineFunctionItemExpr" to "inlineFunctionExpr"           -->
  <xsd:group name="filterExpr">
    <xsd:choice>
      <xsd:element ref="constantExpr"/>
      <xsd:element ref="varRef"/>
      <xsd:element ref="contextItemExpr"/>
      <xsd:element ref="functionCallExpr"/>
      <xsd:element ref="sequenceExpr"/>
      <xsd:element ref="namedFunctionRef"/>
      <xsd:element ref="inlineFunctionExpr"/>
      <xsd:element ref="dynamicFunctionInvocationExpr"/>
    </xsd:choice>
  </xsd:group>


<!-- step expression                                                                    -->
<!-- removed nameTest and Wildcard outer choices per Bugzilla Bug #2523                 -->
<!-- replaced element "predicates" with choice of "predicates" & "dynamicfunctioninv'n" -->
  <xsd:complexType name="stepExpr">
    <xsd:sequence>
      <xsd:choice>
        <xsd:sequence>
          <xsd:element ref="xpathAxis"/>
          <xsd:choice>
            <xsd:element ref="kindTest"/>
            <xsd:element ref="nameTest"/>
            <xsd:element ref="Wildcard"/>
          </xsd:choice>
        </xsd:sequence>
        <xsd:element name="filterExpr">
          <xsd:complexType>
            <xsd:sequence>
              <xsd:group ref="filterExpr"/>
            </xsd:sequence>
          </xsd:complexType>
        </xsd:element>
      </xsd:choice>
      <xsd:element name="predicates" type="exprList" minOccurs="0"/>
    </xsd:sequence>
  </xsd:complexType>

  <xsd:element name="stepExpr" type="stepExpr"/>


<!-- path expression                                                                    -->
<!-- rewrote pathExpr definition per Bugzilla Bug #2523                                 -->
  <xsd:complexType name="pathExpr">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:choice>
          <xsd:sequence>
            <xsd:element name="rootExpr" type="emptyContent"/>
            <xsd:element ref="stepExpr" minOccurs="0" maxOccurs="unbounded"/>
          </xsd:sequence>
          <xsd:element ref="stepExpr" maxOccurs="unbounded"/>
        </xsd:choice>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="pathExpr" type="pathExpr" substitutionGroup="expr"/>


<!-- The following constructs deal with the query prolog -->
  <xsd:complexType name="module">
    <xsd:sequence>
      <xsd:element ref="mainModule"/> 
    </xsd:sequence>
  </xsd:complexType>

  <xsd:element name="module" type="module">

  <xsd:complexType name="mainModule">
    <xsd:sequence>
      <xsd:element name="queryBody" type="exprWrapper"/>
    </xsd:sequence>
  </xsd:complexType>

  <xsd:element name="mainModule" type="mainModule"/>
  <xsd:element name="queryBody" type="exprWrapper"/>

<!-- there is a phrase with diff of chg after sequence and endphrase before typedeclaration -->
  <xsd:complexType name="param">
    <xsd:sequence>
      <xsd:element name="varName" type="EQName"/>
      <xsd:element ref="typeDeclaration" minOccurs="0"/>
    </xsd:sequence>
  </xsd:complexType>

  <xsd:element name="param" type="param"/>


  <xsd:complexType name="paramList">
    <xsd:sequence>
      <xsd:element ref="param" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:complexType>

  <xsd:element name="paramList" type="paramList"/>


</xsd:schema>
