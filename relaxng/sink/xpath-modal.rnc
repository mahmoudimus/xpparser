# Modal fragment of XPath in Relax NG compact syntax
#
#
# Copyright (C) 2016-2017
#   David Baelde, Anthony Lick and Sylvain Schmitz (ENS Cachan)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

default namespace = "http://www.w3.org/2005/XQueryX"
namespace xqx = "http://www.w3.org/2005/XQueryX"

include "xpath-1.0-core.rnc"

op |= element ( eqOp | neOp | equalOp | notEqualOp ) {  # equality
     ( element firstOperand  { unnested.path },
       element secondOperand { local.path } )
   | ( element firstOperand  { local.path },
       element secondOperand { unnested.path } )
}

# an attribute step
attr.step = element stepExpr {
  element xpathAxis { string "attribute" | string "child" },
  element nameTest { external "misc/eqname.rnc" }
}

# a path that remains here
local.path =
    element pathExpr { local.step*, attr.step? }
  | element unionOp {
      element firstOperand  { local.path },
      element secondOperand { local.path }
  }
    
local.step = element stepExpr {
    element filterExpr { element contextItemExpr { empty } }
  | ( element xpathAxis { string "self" }, nodetest )
}

# predicates are only allowed at the end of the path
unnested.path =
    element pathExpr {
        ( element rootExpr { empty }, unnested.step*, step?, attr.step? )
      | ( unnested.step*, step, attr.step? )
    }
  | element contextItemExpr { empty }
  | element unionOp {
      element firstOperand  { unnested.path },
      element secondOperand { unnested.path }
    }
  
unnested.step = element stepExpr {
  (   (axis, nodetest)
    | element filterExpr {
        literal
      | varref
      | element contextItemExpr { empty }
      | cst.fun | fun.root | fun.child
  } )
}