<?xml version="1.0"?>
<!--
This software or document includes material copied from or derived 
from the XQueryX 3.0 W3C Recommendation of 08 April 2014
(https://www.w3.org/TR/2014/REC-xqueryx-30-20140408/).
Copyright © 2014 W3C® (MIT, ERCIM, Keio, Beihang).
-->
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            xmlns="http://www.w3.org/2005/XQueryX"
            targetNamespace="http://www.w3.org/2005/XQueryX"
            elementFormDefault="qualified"
            attributeFormDefault="qualified">

  <!-- Function names -->
  <xsd:include schemaLocation="./fn/any.xsd"/>
  
  <!-- Arithmetic operator expressions -->
  <xsd:include schemaLocation="op/arith.xsd"/>
  
  <!-- String operator expressions -->
  <xsd:include schemaLocation="op/string.xsd"/>

  <!-- Equality comparison expressions -->
  <xsd:include schemaLocation="op/eq.xsd"/>
  
  <!-- Order comparison expressions -->
  <xsd:include schemaLocation="op/order.xsd"/>

  <!-- Node comparison operator expressions -->
  <xsd:include schemaLocation="op/hy.xsd"/>

  <!-- Step expressions -->
  <xsd:include schemaLocation="misc/tests.xsd"/>
  <xsd:include schemaLocation="ax/all.xsd"/>

  <!-- Filter expressions -->
  <xsd:include schemaLocation="misc/constants.xsd"/>
  <xsd:include schemaLocation="fn/dyn.xsd"/>
  <xsd:include schemaLocation="fn/item.xsd"/>

  <!-- `for' and `let' expressions:
  [7] ExprSingle  ::=  ForExpr | LetExpr -->
  <xsd:include schemaLocation="expr/flwor.xsd"/>
  
  <!-- quantified expressions:
  [7] ExprSingle  ::=  QuantifiedExpr -->
  <xsd:include schemaLocation="expr/quant.xsd"/>

  <!-- `treat as' and `instance of' expressions -->
  <xsd:include schemaLocation="expr/instance.xsd"/>
  
  <!-- `castable as' and `cast as' expressions -->
  <xsd:include schemaLocation="expr/cast.xsd"/>

  <!--============================================================
       A few helper declarations -->
  <xsd:complexType name="emptyContent"/>
  
  <xsd:element name="NCName" type="xsd:NCName"/>

  <xsd:complexType name="QName">
    <xsd:simpleContent>
      <xsd:extension base="xsd:NCName">
        <xsd:attribute name="prefix" type="xsd:NCName" use="optional"/>
      </xsd:extension>
    </xsd:simpleContent>
  </xsd:complexType>

  <xsd:complexType name="EQName">
    <xsd:simpleContent>
      <xsd:extension base="xsd:NCName">
        <xsd:attribute name="prefix" type="xsd:NCName" use="optional"/>
        <xsd:attribute name="URI" type="xsd:string" use="optional"/>
      </xsd:extension>
    </xsd:simpleContent>
  </xsd:complexType>

  <!-- By changing the type attribute from QName to EQName, this is now
   atomicOrUnionType.  However, for backwards compatibility w/XQueryX
   1.0, the name had to stay the same
   [81] ItemType           ::=  AtomicOrUnionType
   [82] AtomicOrUnionType  ::=  EQName                                   -->
  <xsd:element name="atomicType" type="EQName" substitutionGroup="itemType"/>
  <xsd:element name="itemType" abstract="true"/>
  
  <!--================================================================
      The base expression class (corresponds to ExprSingle)
  -->
  <xsd:complexType name="expr"/>
  <xsd:element name="expr" type="expr" abstract="true"/>

  <!-- A list of expressions
  [6] Expr  ::=  ExprSingle ("," ExprSingle)*
  -->
  <xsd:complexType name="exprList">
    <xsd:sequence>
      <xsd:element ref="expr" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- A type to be used by elements that comprise an optional expr  -->
  <xsd:complexType name="exprWrapperOptional">
    <xsd:sequence>
      <xsd:element ref="expr" minOccurs="0"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- Simple wrapper class -->
  <xsd:complexType name="exprWrapper">
    <xsd:sequence>
      <xsd:element ref="expr"/>
    </xsd:sequence>
  </xsd:complexType>

  <!-- conditional expressions:
  [7] ExprSingle  ::=  IfExpr -->
  <xsd:complexType name="ifThenElseExpr">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:sequence>
          <xsd:element name="ifClause" type="exprWrapper"/>
          <xsd:element name="thenClause" type="exprWrapper"/>
          <xsd:element name="elseClause" type="exprWrapper"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="ifThenElseExpr" type="ifThenElseExpr" 
               substitutionGroup="expr"/>

  <!--================================================================
       Function call expressions                                             -->  
  <!-- 2010-06-23 - Added support for partial function application           -->
  <xsd:complexType name="functionCallExpr">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:sequence>
          <xsd:element ref="functionName"/> <!-- in fn/*.xsd -->
          <xsd:element name="arguments" type="exprOrPlaceholderList"
                       minOccurs="0"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="functionCallExpr" type="functionCallExpr"
               substitutionGroup="expr"/>
  
  <!-- A list of expressions or placeholders                                 -->
  <!-- 2010-06-23 - Added support for partial function application           -->
  <xsd:complexType name="exprOrPlaceholderList">
    <xsd:sequence>
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
        <xsd:element ref="expr"/>
        <xsd:element name="argumentPlaceholder" type="emptyContent"/>
      </xsd:choice>
    </xsd:sequence>
  </xsd:complexType>

  <!-- =======================================================================
       Builtin operator expressions -->
  <xsd:complexType name="operatorExpr">
    <xsd:complexContent>
      <xsd:extension base="expr"/>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:complexType name="unaryOperatorExpr">
    <xsd:complexContent>
      <xsd:extension base="operatorExpr">
        <xsd:sequence>
          <xsd:element name="operand" type="exprWrapper"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:complexType name="binaryOperatorExpr">
    <xsd:complexContent>
      <xsd:extension base="operatorExpr">
        <xsd:sequence>
          <xsd:element name="firstOperand" type="exprWrapper"/>
          <xsd:element name="secondOperand" type="exprWrapper"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <!-- General operator expressions -->
  <xsd:element name="operatorExpr" type="operatorExpr"
               abstract="true" substitutionGroup="expr"/>
  
  <!-- Comparison operator expressions -->
  <xsd:element name="comparisonOp" type="binaryOperatorExpr" abstract="true"
               substitutionGroup="operatorExpr"/>
  
  <!-- Value comparison operator expressions -->
  <xsd:element name="valueComparisonOp" type="binaryOperatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/>
  
  <!-- General comparison operator expressions -->
  <xsd:element name="generalComparisonOp" type="binaryOperatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/>
    
  <!-- Logical operator expressions -->
  <xsd:element name="logicalOp" type="binaryOperatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/>

  <xsd:element name="andOp" type="binaryOperatorExpr"
               substitutionGroup="logicalOp"/>

  <xsd:element name="orOp" type="binaryOperatorExpr"
               substitutionGroup="logicalOp"/>

  <!-- Set operator expressions -->
  <xsd:element name="setOp" type="binaryOperatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/>
  
  <xsd:element name="unionOp" type="binaryOperatorExpr"
               substitutionGroup="setOp"/>

  <xsd:element name="intersectOp" type="binaryOperatorExpr"
               substitutionGroup="setOp"/>

  <xsd:element name="exceptOp" type="binaryOperatorExpr"
               substitutionGroup="setOp"/>

  <!--==================================================================
      wildcards                                                            -->
  <xsd:complexType name="simpleWildcard">
    <xsd:choice>
      <xsd:element name="QName" type="EQName"/>
      <xsd:element name="star" type="emptyContent"/>
    </xsd:choice>
  </xsd:complexType>

  <!-- 2011-06-10: Redesigned to allow "URliteral:*"                        -->
  <!-- Corresponds to the following XQuery syntax:                          -->
  <!--   [44] Wildcard ::= "*"                                              -->
  <!--                  | (NCName ":" "*")                                  -->
  <!--                  | ("*" ":" NCName)                                  -->
  <!--                  | (URILiteral ":" "*")                              -->
  <xsd:complexType name="Wildcard">
    <xsd:choice minOccurs="0">
      <xsd:sequence>
        <xsd:element name="star" type="emptyContent"/>
        <xsd:element ref="NCName"/>
      </xsd:sequence>
      <xsd:sequence>
        <xsd:element ref="NCName"/>
        <xsd:element name="star" type="emptyContent"/>
      </xsd:sequence>
      <xsd:sequence>
        <xsd:element name="uri" type="xsd:string"/>
        <xsd:element name="star" type="emptyContent"/>
      </xsd:sequence>
    </xsd:choice>
  </xsd:complexType>

  <xsd:element name="Wildcard" type="Wildcard"/>


  <!-- =====================================================================
       filter expressions                                                      -->
  <!-- added literalFunctionItemExpr, inlineFunctionItemExpr, and              -->
  <!--   dynamicFunctionInvocation for higher-order functions                  -->
  <!-- 2011-11-21: Jim changed "literalFunctionItemExpr" to "namedFunctionRef" -->
  <!-- 2011-11-21: Jim changed "inlineFunctionItemExpr" to "inlineFunctionExpr"-->
  <xsd:group name="filterExpr">
    <xsd:choice>
      <xsd:element ref="constantExpr"/>    <!-- in misc/constants.xsd -->
      <xsd:element ref="varRef"/>          <!-- in misc/constants.xsd -->
      <xsd:element ref="contextItemExpr"/> <!-- in misc/constants.xsd -->
      <xsd:element ref="functionCallExpr"/>
      <xsd:element ref="sequenceExpr"/>
      <xsd:element ref="namedFunctionRef"/>   <!-- in fn/item.xsd -->
      <xsd:element ref="inlineFunctionExpr"/> <!-- in fn/item.xsd -->
      <xsd:element ref="dynamicFunctionInvocationExpr"/> <!-- in fn/dyn.xsd -->
    </xsd:choice>
  </xsd:group>


  <!-- =================================================================
       step expression                                                         -->  
  <xsd:complexType name="stepExpr">
    <xsd:sequence>
      <xsd:choice>
        <xsd:sequence>
          <xsd:element ref="xpathAxis"/>  <!-- in ax/*.xsd -->
          <xsd:choice>
            <xsd:element ref="kindTest"/> <!-- in misc/tests.xsd -->
            <xsd:element ref="nameTest"/> <!-- in misc/tests.xsd -->
            <xsd:element ref="Wildcard"/>
          </xsd:choice>
        </xsd:sequence>
        <xsd:element name="filterExpr">
          <xsd:complexType>
            <xsd:sequence>
              <xsd:group ref="filterExpr"/>
            </xsd:sequence>
          </xsd:complexType>
        </xsd:element>
      </xsd:choice>
      <xsd:element name="predicates" type="exprList" minOccurs="0"/>
    </xsd:sequence>
  </xsd:complexType>

  <xsd:element name="stepExpr" type="stepExpr"/>


<!-- path expression                                                          -->
<!-- rewrote pathExpr definition per Bugzilla Bug #2523                       -->
  <xsd:complexType name="pathExpr">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:choice>
          <xsd:sequence>
            <xsd:element name="rootExpr" type="emptyContent"/>
            <xsd:element ref="stepExpr" minOccurs="0" maxOccurs="unbounded"/>
          </xsd:sequence>
          <xsd:element ref="stepExpr" maxOccurs="unbounded"/>
        </xsd:choice>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="pathExpr" type="pathExpr" substitutionGroup="expr"/>

  <!-- ====================================================================
       Sequence expressions                                                  -->
  <xsd:complexType name="sequenceExpr">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:sequence>
          <xsd:element ref="expr" minOccurs="0" maxOccurs="unbounded"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="sequenceExpr" type="sequenceExpr" substitutionGroup="expr"/>


  <xsd:complexType name="rangeSequenceExpr">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:sequence>
          <xsd:element name="startExpr" type="exprWrapper"/>
          <xsd:element name="endExpr" type="exprWrapper"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="rangeSequenceExpr" type="rangeSequenceExpr"
               substitutionGroup="expr"/>  
  
  <!-- Simple map expressions                                                -->
  <!-- 2012-06-15 - Changed precedence and precise grammar for simple map    -->
  <!--              operator                                                 -->
  <!-- 2013-09-27 - Changed definition of simpleMapExpr to allow multiple    -->
  <!--              path expressions                                         -->
  <xsd:complexType name="simpleMapExpr">
    <xsd:complexContent>
      <xsd:extension base="expr">
        <xsd:sequence minOccurs="2" maxOccurs="unbounded">
          <xsd:element ref="pathExpr"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="simpleMapExpr" type="simpleMapExpr"
               substitutionGroup="expr"/>

  
</xsd:schema>
